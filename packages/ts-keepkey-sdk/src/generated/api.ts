/* tslint:disable */
/* eslint-disable */
/**
 * keepkey-desktop
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.14
 * Contact: bithighlander@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BTCGetAddress
 */
export interface BTCGetAddress {
    /**
     * 
     * @type {boolean}
     * @memberof BTCGetAddress
     */
    'showDisplay'?: boolean;
    /**
     * 
     * @type {BTCInputScriptType}
     * @memberof BTCGetAddress
     */
    'scriptType'?: BTCInputScriptType;
    /**
     * 
     * @type {Array<number>}
     * @memberof BTCGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof BTCGetAddress
     */
    'coin': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BTCInputScriptType = {
    Cashaddr: 'cashaddr',
    Bech32: 'bech32',
    P2pkh: 'p2pkh',
    P2sh: 'p2sh',
    External: 'external',
    P2wpkh: 'p2wpkh',
    P2shP2wpkh: 'p2sh-p2wpkh'
} as const;

export type BTCInputScriptType = typeof BTCInputScriptType[keyof typeof BTCInputScriptType];


/**
 * 
 * @export
 * @interface BTCSignedTx
 */
export interface BTCSignedTx {
    /**
     * 
     * @type {Array<string>}
     * @memberof BTCSignedTx
     */
    'signatures': Array<string>;
    /**
     * hex string representation of the raw, signed transaction
     * @type {string}
     * @memberof BTCSignedTx
     */
    'serializedTx': string;
}
/**
 * 
 * @export
 * @interface BinanceGetAddress
 */
export interface BinanceGetAddress {
    /**
     * 
     * @type {Array<number>}
     * @memberof BinanceGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof BinanceGetAddress
     */
    'showDisplay'?: boolean;
}
/**
 * 
 * @export
 * @interface CosmosGetAddress
 */
export interface CosmosGetAddress {
    /**
     * 
     * @type {Array<number>}
     * @memberof CosmosGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosGetAddress
     */
    'showDisplay'?: boolean;
}
/**
 * 
 * @export
 * @interface CosmosSignTx
 */
export interface CosmosSignTx {
    /**
     * 
     * @type {Array<number>}
     * @memberof CosmosSignTx
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {CosmosStdTx}
     * @memberof CosmosSignTx
     */
    'tx': CosmosStdTx;
    /**
     * 
     * @type {string}
     * @memberof CosmosSignTx
     */
    'chain_id': string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSignTx
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSignTx
     */
    'sequence': string;
    /**
     * 
     * @type {number}
     * @memberof CosmosSignTx
     */
    'fee'?: number;
}
/**
 * 
 * @export
 * @interface CosmosSignedTx
 */
export interface CosmosSignedTx {
    /**
     * 
     * @type {string}
     * @memberof CosmosSignedTx
     */
    'serialized': string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSignedTx
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSignedTx
     */
    'authInfoBytes': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CosmosSignedTx
     */
    'signatures': Array<string>;
}
/**
 * 
 * @export
 * @interface CosmosStdTx
 */
export interface CosmosStdTx {
    /**
     * 
     * @type {Array<Msg>}
     * @memberof CosmosStdTx
     */
    'msg': Array<Msg>;
    /**
     * 
     * @type {StdFee}
     * @memberof CosmosStdTx
     */
    'fee': StdFee;
    /**
     * 
     * @type {Array<StdSignature>}
     * @memberof CosmosStdTx
     */
    'signatures': Array<StdSignature>;
    /**
     * 
     * @type {string}
     * @memberof CosmosStdTx
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface CryptoPubKey
 */
export interface CryptoPubKey {
    /**
     * 
     * @type {string}
     * @memberof CryptoPubKey
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CryptoPubKey
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ETHGetAddress
 */
export interface ETHGetAddress {
    /**
     * 
     * @type {Array<number>}
     * @memberof ETHGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ETHGetAddress
     */
    'showDisplay'?: boolean;
}
/**
 * 
 * @export
 * @interface ETHSignedTx
 */
export interface ETHSignedTx {
    /**
     * uint32
     * @type {number}
     * @memberof ETHSignedTx
     */
    'v': number;
    /**
     * big-endian hex, prefixed with \'0x\'
     * @type {string}
     * @memberof ETHSignedTx
     */
    'r': string;
    /**
     * big-endian hex, prefixed with \'0x\'
     * @type {string}
     * @memberof ETHSignedTx
     */
    's': string;
    /**
     * big-endian hex, prefixed with \'0x\'
     * @type {string}
     * @memberof ETHSignedTx
     */
    'serialized': string;
}
/**
 * 
 * @export
 * @interface EosGetPublicKey
 */
export interface EosGetPublicKey {
    /**
     * 
     * @type {Array<number>}
     * @memberof EosGetPublicKey
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof EosGetPublicKey
     */
    'showDisplay'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EosGetPublicKey
     */
    'kind': EosGetPublicKeyKindEnum;
}

export const EosGetPublicKeyKindEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type EosGetPublicKeyKindEnum = typeof EosGetPublicKeyKindEnum[keyof typeof EosGetPublicKeyKindEnum];

/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GenericResponse
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface GetPublicKey
 */
export interface GetPublicKey {
    /**
     * 
     * @type {Array<number>}
     * @memberof GetPublicKey
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublicKey
     */
    'showDisplay'?: boolean;
    /**
     * 
     * @type {BTCInputScriptType}
     * @memberof GetPublicKey
     */
    'scriptType'?: BTCInputScriptType;
    /**
     * 
     * @type {string}
     * @memberof GetPublicKey
     */
    'curve'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicKey
     */
    'coin': string;
    /**
     * 
     * @type {string}
     * @memberof GetPublicKey
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface GetPublicKeys200ResponseInner
 */
export interface GetPublicKeys200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetPublicKeys200ResponseInner
     */
    'xpub': string;
}
/**
 * 
 * @export
 * @interface LoadDevice
 */
export interface LoadDevice {
    /**
     * 12, 18, or 24 word BIP39 mnemonic
     * @type {string}
     * @memberof LoadDevice
     */
    'mnemonic': string;
    /**
     * User-identifiable device label
     * @type {string}
     * @memberof LoadDevice
     */
    'label'?: string;
    /**
     * Whether passphrase protection should be enabled
     * @type {boolean}
     * @memberof LoadDevice
     */
    'passphrase'?: boolean;
    /**
     * pin, in plaintext
     * @type {string}
     * @memberof LoadDevice
     */
    'pin'?: string;
    /**
     * Whether to enforce checksum
     * @type {boolean}
     * @memberof LoadDevice
     */
    'skipChecksum'?: boolean;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {boolean}
     * @memberof ModelError
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface Msg
 */
export interface Msg {
    /**
     * 
     * @type {string}
     * @memberof Msg
     */
    'type': string;
    /**
     * 
     * @type {any}
     * @memberof Msg
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface OsmosisGetAddress
 */
export interface OsmosisGetAddress {
    /**
     * 
     * @type {Array<number>}
     * @memberof OsmosisGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof OsmosisGetAddress
     */
    'showDisplay'?: boolean;
}
/**
 * 
 * @export
 * @interface PairBody
 */
export interface PairBody {
    /**
     * 
     * @type {string}
     * @memberof PairBody
     */
    'serviceName': string;
    /**
     * 
     * @type {string}
     * @memberof PairBody
     */
    'serviceImageUrl': string;
}
/**
 * 
 * @export
 * @interface PairResponse
 */
export interface PairResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PairResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof PairResponse
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'xpub': string;
}
/**
 * 
 * @export
 * @interface ReadDevice200Response
 */
export interface ReadDevice200Response {
    /**
     * 
     * @type {string}
     * @memberof ReadDevice200Response
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface RecoverDevice
 */
export interface RecoverDevice {
    /**
     * Bits. Either 128 (12 words), 192 (18 words), or 256 (24 words)
     * @type {number}
     * @memberof RecoverDevice
     */
    'entropy': RecoverDeviceEntropyEnum;
    /**
     * 
     * @type {string}
     * @memberof RecoverDevice
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof RecoverDevice
     */
    'passphrase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecoverDevice
     */
    'pin': boolean;
    /**
     * 
     * @type {string}
     * @memberof RecoverDevice
     */
    'language'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecoverDevice
     */
    'autoLockDelayMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof RecoverDevice
     */
    'u2fCounter'?: number;
}

export const RecoverDeviceEntropyEnum = {
    NUMBER_128: 128,
    NUMBER_192: 192,
    NUMBER_256: 256
} as const;

export type RecoverDeviceEntropyEnum = typeof RecoverDeviceEntropyEnum[keyof typeof RecoverDeviceEntropyEnum];

/**
 * 
 * @export
 * @interface ResetDevice
 */
export interface ResetDevice {
    /**
     * Bits. Either 128 (12 words), 192 (18 words), or 256 (24 words)
     * @type {number}
     * @memberof ResetDevice
     */
    'entropy'?: ResetDeviceEntropyEnum;
    /**
     * 
     * @type {string}
     * @memberof ResetDevice
     */
    'label': string;
    /**
     * 
     * @type {boolean}
     * @memberof ResetDevice
     */
    'passphrase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResetDevice
     */
    'pin'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ResetDevice
     */
    'autoLockDelayMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResetDevice
     */
    'u2fCounter'?: number;
}

export const ResetDeviceEntropyEnum = {
    NUMBER_128: 128,
    NUMBER_192: 192,
    NUMBER_256: 256
} as const;

export type ResetDeviceEntropyEnum = typeof ResetDeviceEntropyEnum[keyof typeof ResetDeviceEntropyEnum];

/**
 * 
 * @export
 * @interface RippleGetAddress
 */
export interface RippleGetAddress {
    /**
     * 
     * @type {Array<number>}
     * @memberof RippleGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof RippleGetAddress
     */
    'showDisplay'?: boolean;
}
/**
 * 
 * @export
 * @interface RipplePayment
 */
export interface RipplePayment {
    /**
     * 
     * @type {string}
     * @memberof RipplePayment
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof RipplePayment
     */
    'destination': string;
    /**
     * 
     * @type {string}
     * @memberof RipplePayment
     */
    'destinationTag'?: string;
}
/**
 * 
 * @export
 * @interface RippleSignTx
 */
export interface RippleSignTx {
    /**
     * 
     * @type {Array<number>}
     * @memberof RippleSignTx
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {RippleTx}
     * @memberof RippleSignTx
     */
    'tx': RippleTx;
    /**
     * 
     * @type {string}
     * @memberof RippleSignTx
     */
    'flags'?: string;
    /**
     * 
     * @type {string}
     * @memberof RippleSignTx
     */
    'sequence': string;
    /**
     * 
     * @type {string}
     * @memberof RippleSignTx
     */
    'lastLedgerSequence': string;
    /**
     * 
     * @type {RipplePayment}
     * @memberof RippleSignTx
     */
    'payment': RipplePayment;
}
/**
 * 
 * @export
 * @interface RippleStdTx
 */
export interface RippleStdTx {
    /**
     * 
     * @type {Array<SdkMsg>}
     * @memberof RippleStdTx
     */
    'msg': Array<SdkMsg>;
    /**
     * 
     * @type {StdFee}
     * @memberof RippleStdTx
     */
    'fee': StdFee;
    /**
     * 
     * @type {Array<StdSignature>}
     * @memberof RippleStdTx
     */
    'signatures': Array<StdSignature> | null;
    /**
     * 
     * @type {string}
     * @memberof RippleStdTx
     */
    'memo': string;
}
/**
 * 
 * @export
 * @interface RippleTx
 */
export interface RippleTx {
    /**
     * 
     * @type {string}
     * @memberof RippleTx
     */
    'type': string;
    /**
     * 
     * @type {RippleStdTx}
     * @memberof RippleTx
     */
    'value': RippleStdTx;
}
/**
 * 
 * @export
 * @interface SdkMsg
 */
export interface SdkMsg {
    /**
     * 
     * @type {string}
     * @memberof SdkMsg
     */
    'type': string;
    /**
     * 
     * @type {any}
     * @memberof SdkMsg
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface SignTransaction200Response
 */
export interface SignTransaction200Response {
    /**
     * 
     * @type {boolean}
     * @memberof SignTransaction200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof SignTransaction200Response
     */
    'status': string;
    /**
     * 
     * @type {any}
     * @memberof SignTransaction200Response
     */
    'signedTx': any;
    /**
     * 
     * @type {string}
     * @memberof SignTransaction200Response
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface SignedTx
 */
export interface SignedTx {
    /**
     * 
     * @type {boolean}
     * @memberof SignedTx
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof SignedTx
     */
    'status': string;
    /**
     * 
     * @type {any}
     * @memberof SignedTx
     */
    'signedTx': any;
}
/**
 * 
 * @export
 * @interface StdFee
 */
export interface StdFee {
    /**
     * 
     * @type {Array<string>}
     * @memberof StdFee
     */
    'amount': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StdFee
     */
    'gas': string;
}
/**
 * 
 * @export
 * @interface StdSignature
 */
export interface StdSignature {
    /**
     * 
     * @type {CryptoPubKey}
     * @memberof StdSignature
     */
    'pub_key': CryptoPubKey;
    /**
     * 
     * @type {string}
     * @memberof StdSignature
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface ThorchainGetAddress
 */
export interface ThorchainGetAddress {
    /**
     * 
     * @type {Array<number>}
     * @memberof ThorchainGetAddress
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ThorchainGetAddress
     */
    'showDisplay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThorchainGetAddress
     */
    'testnet'?: boolean;
}
/**
 * 
 * @export
 * @interface ThorchainMsg
 */
export interface ThorchainMsg {
    /**
     * 
     * @type {string}
     * @memberof ThorchainMsg
     */
    'type': string;
    /**
     * 
     * @type {any}
     * @memberof ThorchainMsg
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface ThorchainSignTx
 */
export interface ThorchainSignTx {
    /**
     * 
     * @type {Array<number>}
     * @memberof ThorchainSignTx
     */
    'addressNList': Array<number>;
    /**
     * 
     * @type {ThorchainStdTx}
     * @memberof ThorchainSignTx
     */
    'tx': ThorchainStdTx;
    /**
     * 
     * @type {string}
     * @memberof ThorchainSignTx
     */
    'sequence': string;
    /**
     * 
     * @type {string}
     * @memberof ThorchainSignTx
     */
    'account_number': string;
    /**
     * 
     * @type {string}
     * @memberof ThorchainSignTx
     */
    'chain_id': string;
    /**
     * 
     * @type {number}
     * @memberof ThorchainSignTx
     */
    'fee'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThorchainSignTx
     */
    'testnet'?: boolean;
}
/**
 * 
 * @export
 * @interface ThorchainStdFee
 */
export interface ThorchainStdFee {
    /**
     * 
     * @type {Array<string>}
     * @memberof ThorchainStdFee
     */
    'amount': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ThorchainStdFee
     */
    'gas': string;
}
/**
 * 
 * @export
 * @interface ThorchainStdSignature
 */
export interface ThorchainStdSignature {
    /**
     * 
     * @type {CryptoPubKey}
     * @memberof ThorchainStdSignature
     */
    'pub_key': CryptoPubKey;
    /**
     * 
     * @type {string}
     * @memberof ThorchainStdSignature
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface ThorchainStdTx
 */
export interface ThorchainStdTx {
    /**
     * 
     * @type {StdFee}
     * @memberof ThorchainStdTx
     */
    'fee': StdFee;
    /**
     * 
     * @type {string}
     * @memberof ThorchainStdTx
     */
    'memo'?: string;
    /**
     * 
     * @type {Array<Msg>}
     * @memberof ThorchainStdTx
     */
    'msg': Array<Msg>;
    /**
     * 
     * @type {Array<StdSignature>}
     * @memberof ThorchainStdTx
     */
    'signatures': Array<StdSignature>;
}
/**
 * 
 * @export
 * @interface ThorchainTx
 */
export interface ThorchainTx {
    /**
     * 
     * @type {Array<ThorchainMsg>}
     * @memberof ThorchainTx
     */
    'msg': Array<ThorchainMsg>;
    /**
     * 
     * @type {ThorchainStdFee}
     * @memberof ThorchainTx
     */
    'fee': ThorchainStdFee;
    /**
     * 
     * @type {Array<ThorchainStdSignature>}
     * @memberof ThorchainTx
     */
    'signatures': Array<ThorchainStdSignature>;
    /**
     * 
     * @type {string}
     * @memberof ThorchainTx
     */
    'memo'?: string;
}
/**
 * 
 * @export
 * @interface UserType
 */
export interface UserType {
    /**
     * 
     * @type {Array<any>}
     * @memberof UserType
     */
    'balances': Array<any>;
    /**
     * 
     * @type {Array<UserTypeAccountsInner>}
     * @memberof UserType
     */
    'accounts': Array<UserTypeAccountsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof UserType
     */
    'online': boolean;
}
/**
 * 
 * @export
 * @interface UserTypeAccountsInner
 */
export interface UserTypeAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof UserTypeAccountsInner
     */
    'caip': string;
    /**
     * 
     * @type {any}
     * @memberof UserTypeAccountsInner
     */
    'pubkey': any;
}
/**
 * 
 * @export
 * @interface WriteBody
 */
export interface WriteBody {
    /**
     * 
     * @type {any}
     * @memberof WriteBody
     */
    'data': any;
}
/**
 * 
 * @export
 * @interface WriteDevice200Response
 */
export interface WriteDevice200Response {
    /**
     * 
     * @type {string}
     * @memberof WriteDevice200Response
     */
    'output': string;
}

/**
 * ClientEndpointsApi - axios parameter creator
 * @export
 */
export const ClientEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        device: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} authorization 
         * @param {PairBody} pairBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pair: async (authorization: string, pairBody: PairBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('pair', 'authorization', authorization)
            // verify required parameter 'pairBody' is not null or undefined
            assertParamExists('pair', 'pairBody', pairBody)
            const localVarPath = `/pair`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pairBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientEndpointsApi - functional programming interface
 * @export
 */
export const ClientEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async device(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.device(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} authorization 
         * @param {PairBody} pairBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pair(authorization: string, pairBody: PairBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PairResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pair(authorization, pairBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async user(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.user(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyAuth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyAuth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientEndpointsApi - factory interface
 * @export
 */
export const ClientEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        device(options?: any): AxiosPromise<object> {
            return localVarFp.device(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} authorization 
         * @param {PairBody} pairBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pair(authorization: string, pairBody: PairBody, options?: any): AxiosPromise<PairResponse> {
            return localVarFp.pair(authorization, pairBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(options?: any): AxiosPromise<string> {
            return localVarFp.status(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user(options?: any): AxiosPromise<UserType> {
            return localVarFp.user(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAuth(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.verifyAuth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for pair operation in ClientEndpointsApi.
 * @export
 * @interface ClientEndpointsApiPairRequest
 */
export interface ClientEndpointsApiPairRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientEndpointsApiPair
     */
    readonly authorization: string

    /**
     * 
     * @type {PairBody}
     * @memberof ClientEndpointsApiPair
     */
    readonly pairBody: PairBody
}

/**
 * ClientEndpointsApi - object-oriented interface
 * @export
 * @class ClientEndpointsApi
 * @extends {BaseAPI}
 */
export class ClientEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientEndpointsApi
     */
    public device(options?: AxiosRequestConfig) {
        return ClientEndpointsApiFp(this.configuration).device(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClientEndpointsApiPairRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientEndpointsApi
     */
    public pair(requestParameters: ClientEndpointsApiPairRequest, options?: AxiosRequestConfig) {
        return ClientEndpointsApiFp(this.configuration).pair(requestParameters.authorization, requestParameters.pairBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientEndpointsApi
     */
    public status(options?: AxiosRequestConfig) {
        return ClientEndpointsApiFp(this.configuration).status(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientEndpointsApi
     */
    public user(options?: AxiosRequestConfig) {
        return ClientEndpointsApiFp(this.configuration).user(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientEndpointsApi
     */
    public verifyAuth(options?: AxiosRequestConfig) {
        return ClientEndpointsApiFp(this.configuration).verifyAuth(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeveloperEndpointsApi - axios parameter creator
 * @export
 */
export const DeveloperEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyPolicy: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('applyPolicy', 'body', body)
            const localVarPath = `/applyPolicy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySettings: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('applySettings', 'body', body)
            const localVarPath = `/applySettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearSession: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('clearSession', 'body', body)
            const localVarPath = `/clearSession`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnect: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('disconnect', 'body', body)
            const localVarPath = `/disconnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firmwareErase: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('firmwareErase', 'body', body)
            const localVarPath = `/firmwareErase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firmwareUpload: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('firmwareUpload', 'body', body)
            const localVarPath = `/firmwareUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoadDevice} loadDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadDevice: async (loadDevice: LoadDevice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loadDevice' is not null or undefined
            assertParamExists('loadDevice', 'loadDevice', loadDevice)
            const localVarPath = `/loadDevice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loadDevice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/removePin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetDevice} resetDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset: async (resetDevice: ResetDevice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetDevice' is not null or undefined
            assertParamExists('reset', 'resetDevice', resetDevice)
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetDevice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softReset: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('softReset', 'body', body)
            const localVarPath = `/softReset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wipe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeveloperEndpointsApi - functional programming interface
 * @export
 */
export const DeveloperEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeveloperEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyPolicy(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyPolicy(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applySettings(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applySettings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearSession(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearSession(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnect(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnect(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firmwareErase(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firmwareErase(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firmwareUpload(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firmwareUpload(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoadDevice} loadDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadDevice(loadDevice: LoadDevice, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadDevice(loadDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ResetDevice} resetDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reset(resetDevice: ResetDevice, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reset(resetDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async softReset(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.softReset(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wipe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wipe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeveloperEndpointsApi - factory interface
 * @export
 */
export const DeveloperEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeveloperEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyPolicy(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.applyPolicy(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySettings(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.applySettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearSession(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.clearSession(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnect(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.disconnect(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firmwareErase(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.firmwareErase(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firmwareUpload(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.firmwareUpload(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoadDevice} loadDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadDevice(loadDevice: LoadDevice, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.loadDevice(loadDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePin(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.removePin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetDevice} resetDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset(resetDevice: ResetDevice, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.reset(resetDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        softReset(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.softReset(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wipe(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.wipe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applyPolicy operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiApplyPolicyRequest
 */
export interface DeveloperEndpointsApiApplyPolicyRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiApplyPolicy
     */
    readonly body: any
}

/**
 * Request parameters for applySettings operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiApplySettingsRequest
 */
export interface DeveloperEndpointsApiApplySettingsRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiApplySettings
     */
    readonly body: any
}

/**
 * Request parameters for clearSession operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiClearSessionRequest
 */
export interface DeveloperEndpointsApiClearSessionRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiClearSession
     */
    readonly body: any
}

/**
 * Request parameters for disconnect operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiDisconnectRequest
 */
export interface DeveloperEndpointsApiDisconnectRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiDisconnect
     */
    readonly body: any
}

/**
 * Request parameters for firmwareErase operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiFirmwareEraseRequest
 */
export interface DeveloperEndpointsApiFirmwareEraseRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiFirmwareErase
     */
    readonly body: any
}

/**
 * Request parameters for firmwareUpload operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiFirmwareUploadRequest
 */
export interface DeveloperEndpointsApiFirmwareUploadRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiFirmwareUpload
     */
    readonly body: any
}

/**
 * Request parameters for loadDevice operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiLoadDeviceRequest
 */
export interface DeveloperEndpointsApiLoadDeviceRequest {
    /**
     * 
     * @type {LoadDevice}
     * @memberof DeveloperEndpointsApiLoadDevice
     */
    readonly loadDevice: LoadDevice
}

/**
 * Request parameters for reset operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiResetRequest
 */
export interface DeveloperEndpointsApiResetRequest {
    /**
     * 
     * @type {ResetDevice}
     * @memberof DeveloperEndpointsApiReset
     */
    readonly resetDevice: ResetDevice
}

/**
 * Request parameters for softReset operation in DeveloperEndpointsApi.
 * @export
 * @interface DeveloperEndpointsApiSoftResetRequest
 */
export interface DeveloperEndpointsApiSoftResetRequest {
    /**
     * 
     * @type {any}
     * @memberof DeveloperEndpointsApiSoftReset
     */
    readonly body: any
}

/**
 * DeveloperEndpointsApi - object-oriented interface
 * @export
 * @class DeveloperEndpointsApi
 * @extends {BaseAPI}
 */
export class DeveloperEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {DeveloperEndpointsApiApplyPolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public applyPolicy(requestParameters: DeveloperEndpointsApiApplyPolicyRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).applyPolicy(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiApplySettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public applySettings(requestParameters: DeveloperEndpointsApiApplySettingsRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).applySettings(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiClearSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public clearSession(requestParameters: DeveloperEndpointsApiClearSessionRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).clearSession(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiDisconnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public disconnect(requestParameters: DeveloperEndpointsApiDisconnectRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).disconnect(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiFirmwareEraseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public firmwareErase(requestParameters: DeveloperEndpointsApiFirmwareEraseRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).firmwareErase(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiFirmwareUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public firmwareUpload(requestParameters: DeveloperEndpointsApiFirmwareUploadRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).firmwareUpload(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiLoadDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public loadDevice(requestParameters: DeveloperEndpointsApiLoadDeviceRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).loadDevice(requestParameters.loadDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public removePin(options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).removePin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiResetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public reset(requestParameters: DeveloperEndpointsApiResetRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).reset(requestParameters.resetDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeveloperEndpointsApiSoftResetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public softReset(requestParameters: DeveloperEndpointsApiSoftResetRequest, options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).softReset(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeveloperEndpointsApi
     */
    public wipe(options?: AxiosRequestConfig) {
        return DeveloperEndpointsApiFp(this.configuration).wipe(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceInfoEndpointsApi - axios parameter creator
 * @export
 */
export const DeviceInfoEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinTable: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getCoinTable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceID: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getDeviceID`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirmwareVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getFirmwareVersion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabel: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getLabel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getModel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNumCoins: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getNumCoins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendor: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getVendor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDeviceDisplay: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hasOnDeviceDisplay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDevicePassphrase: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hasOnDevicePassphrase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDevicePinEntry: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hasOnDevicePinEntry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDeviceRecovery: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hasOnDeviceRecovery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInitialized: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/isInitialized`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLocked: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/isLocked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceInfoEndpointsApi - functional programming interface
 * @export
 */
export const DeviceInfoEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceInfoEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoinTable(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoinTable(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceID(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceID(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirmwareVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFirmwareVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabel(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabel(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNumCoins(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNumCoins(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVendor(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVendor(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasOnDeviceDisplay(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasOnDeviceDisplay(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasOnDevicePassphrase(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasOnDevicePassphrase(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasOnDevicePinEntry(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasOnDevicePinEntry(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasOnDeviceRecovery(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasOnDeviceRecovery(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInitialized(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isInitialized(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isLocked(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isLocked(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceInfoEndpointsApi - factory interface
 * @export
 */
export const DeviceInfoEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceInfoEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinTable(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getCoinTable(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceID(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getDeviceID(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirmwareVersion(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getFirmwareVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabel(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getLabel(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getModel(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNumCoins(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getNumCoins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVendor(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.getVendor(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDeviceDisplay(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.hasOnDeviceDisplay(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDevicePassphrase(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.hasOnDevicePassphrase(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDevicePinEntry(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.hasOnDevicePinEntry(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasOnDeviceRecovery(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.hasOnDeviceRecovery(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInitialized(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.isInitialized(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLocked(options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.isLocked(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceInfoEndpointsApi - object-oriented interface
 * @export
 * @class DeviceInfoEndpointsApi
 * @extends {BaseAPI}
 */
export class DeviceInfoEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getCoinTable(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getCoinTable(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getDeviceID(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getDeviceID(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getFirmwareVersion(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getFirmwareVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getLabel(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getLabel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getModel(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getModel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getNumCoins(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getNumCoins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public getVendor(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).getVendor(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public hasOnDeviceDisplay(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).hasOnDeviceDisplay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public hasOnDevicePassphrase(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).hasOnDevicePassphrase(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public hasOnDevicePinEntry(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).hasOnDevicePinEntry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public hasOnDeviceRecovery(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).hasOnDeviceRecovery(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public isInitialized(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).isInitialized(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoEndpointsApi
     */
    public isLocked(options?: AxiosRequestConfig) {
        return DeviceInfoEndpointsApiFp(this.configuration).isLocked(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeepKeySignTxEndpointsApi - axios parameter creator
 * @export
 */
export const KeepKeySignTxEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        binanceSignTx: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('binanceSignTx', 'body', body)
            const localVarPath = `/binanceSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        btcSignTx: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('btcSignTx', 'body', body)
            const localVarPath = `/btcSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CosmosSignTx} cosmosSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cosmosSignTx: async (cosmosSignTx: CosmosSignTx, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cosmosSignTx' is not null or undefined
            assertParamExists('cosmosSignTx', 'cosmosSignTx', cosmosSignTx)
            const localVarPath = `/cosmosSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cosmosSignTx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eosSignTx: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('eosSignTx', 'body', body)
            const localVarPath = `/eosSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ethSignTx: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ethSignTx', 'body', body)
            const localVarPath = `/ethSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osmosisSignTx: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('osmosisSignTx', 'body', body)
            const localVarPath = `/osmosisSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RippleSignTx} rippleSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rippleSignTx: async (rippleSignTx: RippleSignTx, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rippleSignTx' is not null or undefined
            assertParamExists('rippleSignTx', 'rippleSignTx', rippleSignTx)
            const localVarPath = `/rippleSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rippleSignTx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('signTransaction', 'body', body)
            const localVarPath = `/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ThorchainSignTx} thorchainSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorchainSignTx: async (thorchainSignTx: ThorchainSignTx, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thorchainSignTx' is not null or undefined
            assertParamExists('thorchainSignTx', 'thorchainSignTx', thorchainSignTx)
            const localVarPath = `/thorchainSignTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thorchainSignTx, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeepKeySignTxEndpointsApi - functional programming interface
 * @export
 */
export const KeepKeySignTxEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeepKeySignTxEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async binanceSignTx(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.binanceSignTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async btcSignTx(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BTCSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.btcSignTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CosmosSignTx} cosmosSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cosmosSignTx(cosmosSignTx: CosmosSignTx, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CosmosSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cosmosSignTx(cosmosSignTx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eosSignTx(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eosSignTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ethSignTx(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ethSignTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osmosisSignTx(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osmosisSignTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RippleSignTx} rippleSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rippleSignTx(rippleSignTx: RippleSignTx, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RippleTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rippleSignTx(rippleSignTx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTransaction(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignTransaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTransaction(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ThorchainSignTx} thorchainSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thorchainSignTx(thorchainSignTx: ThorchainSignTx, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thorchainSignTx(thorchainSignTx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeepKeySignTxEndpointsApi - factory interface
 * @export
 */
export const KeepKeySignTxEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeepKeySignTxEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        binanceSignTx(body: any, options?: any): AxiosPromise<any> {
            return localVarFp.binanceSignTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        btcSignTx(body: any, options?: any): AxiosPromise<BTCSignedTx> {
            return localVarFp.btcSignTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CosmosSignTx} cosmosSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cosmosSignTx(cosmosSignTx: CosmosSignTx, options?: any): AxiosPromise<CosmosSignedTx> {
            return localVarFp.cosmosSignTx(cosmosSignTx, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eosSignTx(body: any, options?: any): AxiosPromise<any> {
            return localVarFp.eosSignTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ethSignTx(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.ethSignTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osmosisSignTx(body: any, options?: any): AxiosPromise<any> {
            return localVarFp.osmosisSignTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RippleSignTx} rippleSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rippleSignTx(rippleSignTx: RippleSignTx, options?: any): AxiosPromise<RippleTx> {
            return localVarFp.rippleSignTx(rippleSignTx, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTransaction(body: any, options?: any): AxiosPromise<SignTransaction200Response> {
            return localVarFp.signTransaction(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ThorchainSignTx} thorchainSignTx 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorchainSignTx(thorchainSignTx: ThorchainSignTx, options?: any): AxiosPromise<ThorchainTx> {
            return localVarFp.thorchainSignTx(thorchainSignTx, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for binanceSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiBinanceSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiBinanceSignTxRequest {
    /**
     * 
     * @type {any}
     * @memberof KeepKeySignTxEndpointsApiBinanceSignTx
     */
    readonly body: any
}

/**
 * Request parameters for btcSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiBtcSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiBtcSignTxRequest {
    /**
     * 
     * @type {any}
     * @memberof KeepKeySignTxEndpointsApiBtcSignTx
     */
    readonly body: any
}

/**
 * Request parameters for cosmosSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiCosmosSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiCosmosSignTxRequest {
    /**
     * 
     * @type {CosmosSignTx}
     * @memberof KeepKeySignTxEndpointsApiCosmosSignTx
     */
    readonly cosmosSignTx: CosmosSignTx
}

/**
 * Request parameters for eosSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiEosSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiEosSignTxRequest {
    /**
     * 
     * @type {any}
     * @memberof KeepKeySignTxEndpointsApiEosSignTx
     */
    readonly body: any
}

/**
 * Request parameters for ethSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiEthSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiEthSignTxRequest {
    /**
     * 
     * @type {any}
     * @memberof KeepKeySignTxEndpointsApiEthSignTx
     */
    readonly body: any
}

/**
 * Request parameters for osmosisSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiOsmosisSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiOsmosisSignTxRequest {
    /**
     * 
     * @type {any}
     * @memberof KeepKeySignTxEndpointsApiOsmosisSignTx
     */
    readonly body: any
}

/**
 * Request parameters for rippleSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiRippleSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiRippleSignTxRequest {
    /**
     * 
     * @type {RippleSignTx}
     * @memberof KeepKeySignTxEndpointsApiRippleSignTx
     */
    readonly rippleSignTx: RippleSignTx
}

/**
 * Request parameters for signTransaction operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiSignTransactionRequest
 */
export interface KeepKeySignTxEndpointsApiSignTransactionRequest {
    /**
     * 
     * @type {any}
     * @memberof KeepKeySignTxEndpointsApiSignTransaction
     */
    readonly body: any
}

/**
 * Request parameters for thorchainSignTx operation in KeepKeySignTxEndpointsApi.
 * @export
 * @interface KeepKeySignTxEndpointsApiThorchainSignTxRequest
 */
export interface KeepKeySignTxEndpointsApiThorchainSignTxRequest {
    /**
     * 
     * @type {ThorchainSignTx}
     * @memberof KeepKeySignTxEndpointsApiThorchainSignTx
     */
    readonly thorchainSignTx: ThorchainSignTx
}

/**
 * KeepKeySignTxEndpointsApi - object-oriented interface
 * @export
 * @class KeepKeySignTxEndpointsApi
 * @extends {BaseAPI}
 */
export class KeepKeySignTxEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {KeepKeySignTxEndpointsApiBinanceSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public binanceSignTx(requestParameters: KeepKeySignTxEndpointsApiBinanceSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).binanceSignTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiBtcSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public btcSignTx(requestParameters: KeepKeySignTxEndpointsApiBtcSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).btcSignTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiCosmosSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public cosmosSignTx(requestParameters: KeepKeySignTxEndpointsApiCosmosSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).cosmosSignTx(requestParameters.cosmosSignTx, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiEosSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public eosSignTx(requestParameters: KeepKeySignTxEndpointsApiEosSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).eosSignTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiEthSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public ethSignTx(requestParameters: KeepKeySignTxEndpointsApiEthSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).ethSignTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiOsmosisSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public osmosisSignTx(requestParameters: KeepKeySignTxEndpointsApiOsmosisSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).osmosisSignTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiRippleSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public rippleSignTx(requestParameters: KeepKeySignTxEndpointsApiRippleSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).rippleSignTx(requestParameters.rippleSignTx, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiSignTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public signTransaction(requestParameters: KeepKeySignTxEndpointsApiSignTransactionRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).signTransaction(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeySignTxEndpointsApiThorchainSignTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeySignTxEndpointsApi
     */
    public thorchainSignTx(requestParameters: KeepKeySignTxEndpointsApiThorchainSignTxRequest, options?: AxiosRequestConfig) {
        return KeepKeySignTxEndpointsApiFp(this.configuration).thorchainSignTx(requestParameters.thorchainSignTx, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeepKeyWalletEndpointsApi - axios parameter creator
 * @export
 */
export const KeepKeyWalletEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BinanceGetAddress} binanceGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        binanceGetAddress: async (binanceGetAddress: BinanceGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'binanceGetAddress' is not null or undefined
            assertParamExists('binanceGetAddress', 'binanceGetAddress', binanceGetAddress)
            const localVarPath = `/binanceGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(binanceGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BTCGetAddress} bTCGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        btcGetAddress: async (bTCGetAddress: BTCGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bTCGetAddress' is not null or undefined
            assertParamExists('btcGetAddress', 'bTCGetAddress', bTCGetAddress)
            const localVarPath = `/btcGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bTCGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CosmosGetAddress} cosmosGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cosmosGetAddress: async (cosmosGetAddress: CosmosGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cosmosGetAddress' is not null or undefined
            assertParamExists('cosmosGetAddress', 'cosmosGetAddress', cosmosGetAddress)
            const localVarPath = `/cosmosGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cosmosGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EosGetPublicKey} eosGetPublicKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eosGetPublicKey: async (eosGetPublicKey: EosGetPublicKey, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eosGetPublicKey' is not null or undefined
            assertParamExists('eosGetPublicKey', 'eosGetPublicKey', eosGetPublicKey)
            const localVarPath = `/eosGetPublicKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eosGetPublicKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ETHGetAddress} eTHGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ethGetAddress: async (eTHGetAddress: ETHGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eTHGetAddress' is not null or undefined
            assertParamExists('ethGetAddress', 'eTHGetAddress', eTHGetAddress)
            const localVarPath = `/ethGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eTHGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<GetPublicKey>} getPublicKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys: async (getPublicKey: Array<GetPublicKey>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getPublicKey' is not null or undefined
            assertParamExists('getPublicKeys', 'getPublicKey', getPublicKey)
            const localVarPath = `/getPublicKeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPublicKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OsmosisGetAddress} osmosisGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osmosisGetAddress: async (osmosisGetAddress: OsmosisGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'osmosisGetAddress' is not null or undefined
            assertParamExists('osmosisGetAddress', 'osmosisGetAddress', osmosisGetAddress)
            const localVarPath = `/osmosisGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osmosisGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RippleGetAddress} rippleGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rippleGetAddress: async (rippleGetAddress: RippleGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rippleGetAddress' is not null or undefined
            assertParamExists('rippleGetAddress', 'rippleGetAddress', rippleGetAddress)
            const localVarPath = `/rippleGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rippleGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ThorchainGetAddress} thorchainGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorchainGetAddress: async (thorchainGetAddress: ThorchainGetAddress, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thorchainGetAddress' is not null or undefined
            assertParamExists('thorchainGetAddress', 'thorchainGetAddress', thorchainGetAddress)
            const localVarPath = `/thorchainGetAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thorchainGetAddress, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeepKeyWalletEndpointsApi - functional programming interface
 * @export
 */
export const KeepKeyWalletEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeepKeyWalletEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BinanceGetAddress} binanceGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async binanceGetAddress(binanceGetAddress: BinanceGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.binanceGetAddress(binanceGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BTCGetAddress} bTCGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async btcGetAddress(bTCGetAddress: BTCGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.btcGetAddress(bTCGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CosmosGetAddress} cosmosGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cosmosGetAddress(cosmosGetAddress: CosmosGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cosmosGetAddress(cosmosGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {EosGetPublicKey} eosGetPublicKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eosGetPublicKey(eosGetPublicKey: EosGetPublicKey, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eosGetPublicKey(eosGetPublicKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ETHGetAddress} eTHGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ethGetAddress(eTHGetAddress: ETHGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ethGetAddress(eTHGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<GetPublicKey>} getPublicKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKeys(getPublicKey: Array<GetPublicKey>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPublicKeys200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(getPublicKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OsmosisGetAddress} osmosisGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osmosisGetAddress(osmosisGetAddress: OsmosisGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osmosisGetAddress(osmosisGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RippleGetAddress} rippleGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rippleGetAddress(rippleGetAddress: RippleGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rippleGetAddress(rippleGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ThorchainGetAddress} thorchainGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thorchainGetAddress(thorchainGetAddress: ThorchainGetAddress, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thorchainGetAddress(thorchainGetAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeepKeyWalletEndpointsApi - factory interface
 * @export
 */
export const KeepKeyWalletEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeepKeyWalletEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {BinanceGetAddress} binanceGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        binanceGetAddress(binanceGetAddress: BinanceGetAddress, options?: any): AxiosPromise<string> {
            return localVarFp.binanceGetAddress(binanceGetAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BTCGetAddress} bTCGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        btcGetAddress(bTCGetAddress: BTCGetAddress, options?: any): AxiosPromise<string> {
            return localVarFp.btcGetAddress(bTCGetAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CosmosGetAddress} cosmosGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cosmosGetAddress(cosmosGetAddress: CosmosGetAddress, options?: any): AxiosPromise<string> {
            return localVarFp.cosmosGetAddress(cosmosGetAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EosGetPublicKey} eosGetPublicKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eosGetPublicKey(eosGetPublicKey: EosGetPublicKey, options?: any): AxiosPromise<string> {
            return localVarFp.eosGetPublicKey(eosGetPublicKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ETHGetAddress} eTHGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ethGetAddress(eTHGetAddress: ETHGetAddress, options?: any): AxiosPromise<string> {
            return localVarFp.ethGetAddress(eTHGetAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<GetPublicKey>} getPublicKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeys(getPublicKey: Array<GetPublicKey>, options?: any): AxiosPromise<Array<GetPublicKeys200ResponseInner>> {
            return localVarFp.getPublicKeys(getPublicKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OsmosisGetAddress} osmosisGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osmosisGetAddress(osmosisGetAddress: OsmosisGetAddress, options?: any): AxiosPromise<any> {
            return localVarFp.osmosisGetAddress(osmosisGetAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RippleGetAddress} rippleGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rippleGetAddress(rippleGetAddress: RippleGetAddress, options?: any): AxiosPromise<string> {
            return localVarFp.rippleGetAddress(rippleGetAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ThorchainGetAddress} thorchainGetAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thorchainGetAddress(thorchainGetAddress: ThorchainGetAddress, options?: any): AxiosPromise<string> {
            return localVarFp.thorchainGetAddress(thorchainGetAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for binanceGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiBinanceGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiBinanceGetAddressRequest {
    /**
     * 
     * @type {BinanceGetAddress}
     * @memberof KeepKeyWalletEndpointsApiBinanceGetAddress
     */
    readonly binanceGetAddress: BinanceGetAddress
}

/**
 * Request parameters for btcGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiBtcGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiBtcGetAddressRequest {
    /**
     * 
     * @type {BTCGetAddress}
     * @memberof KeepKeyWalletEndpointsApiBtcGetAddress
     */
    readonly bTCGetAddress: BTCGetAddress
}

/**
 * Request parameters for cosmosGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiCosmosGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiCosmosGetAddressRequest {
    /**
     * 
     * @type {CosmosGetAddress}
     * @memberof KeepKeyWalletEndpointsApiCosmosGetAddress
     */
    readonly cosmosGetAddress: CosmosGetAddress
}

/**
 * Request parameters for eosGetPublicKey operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiEosGetPublicKeyRequest
 */
export interface KeepKeyWalletEndpointsApiEosGetPublicKeyRequest {
    /**
     * 
     * @type {EosGetPublicKey}
     * @memberof KeepKeyWalletEndpointsApiEosGetPublicKey
     */
    readonly eosGetPublicKey: EosGetPublicKey
}

/**
 * Request parameters for ethGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiEthGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiEthGetAddressRequest {
    /**
     * 
     * @type {ETHGetAddress}
     * @memberof KeepKeyWalletEndpointsApiEthGetAddress
     */
    readonly eTHGetAddress: ETHGetAddress
}

/**
 * Request parameters for getPublicKeys operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiGetPublicKeysRequest
 */
export interface KeepKeyWalletEndpointsApiGetPublicKeysRequest {
    /**
     * 
     * @type {Array<GetPublicKey>}
     * @memberof KeepKeyWalletEndpointsApiGetPublicKeys
     */
    readonly getPublicKey: Array<GetPublicKey>
}

/**
 * Request parameters for osmosisGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiOsmosisGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiOsmosisGetAddressRequest {
    /**
     * 
     * @type {OsmosisGetAddress}
     * @memberof KeepKeyWalletEndpointsApiOsmosisGetAddress
     */
    readonly osmosisGetAddress: OsmosisGetAddress
}

/**
 * Request parameters for rippleGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiRippleGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiRippleGetAddressRequest {
    /**
     * 
     * @type {RippleGetAddress}
     * @memberof KeepKeyWalletEndpointsApiRippleGetAddress
     */
    readonly rippleGetAddress: RippleGetAddress
}

/**
 * Request parameters for thorchainGetAddress operation in KeepKeyWalletEndpointsApi.
 * @export
 * @interface KeepKeyWalletEndpointsApiThorchainGetAddressRequest
 */
export interface KeepKeyWalletEndpointsApiThorchainGetAddressRequest {
    /**
     * 
     * @type {ThorchainGetAddress}
     * @memberof KeepKeyWalletEndpointsApiThorchainGetAddress
     */
    readonly thorchainGetAddress: ThorchainGetAddress
}

/**
 * KeepKeyWalletEndpointsApi - object-oriented interface
 * @export
 * @class KeepKeyWalletEndpointsApi
 * @extends {BaseAPI}
 */
export class KeepKeyWalletEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {KeepKeyWalletEndpointsApiBinanceGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public binanceGetAddress(requestParameters: KeepKeyWalletEndpointsApiBinanceGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).binanceGetAddress(requestParameters.binanceGetAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiBtcGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public btcGetAddress(requestParameters: KeepKeyWalletEndpointsApiBtcGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).btcGetAddress(requestParameters.bTCGetAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiCosmosGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public cosmosGetAddress(requestParameters: KeepKeyWalletEndpointsApiCosmosGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).cosmosGetAddress(requestParameters.cosmosGetAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiEosGetPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public eosGetPublicKey(requestParameters: KeepKeyWalletEndpointsApiEosGetPublicKeyRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).eosGetPublicKey(requestParameters.eosGetPublicKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiEthGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public ethGetAddress(requestParameters: KeepKeyWalletEndpointsApiEthGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).ethGetAddress(requestParameters.eTHGetAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiGetPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public getPublicKeys(requestParameters: KeepKeyWalletEndpointsApiGetPublicKeysRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).getPublicKeys(requestParameters.getPublicKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiOsmosisGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public osmosisGetAddress(requestParameters: KeepKeyWalletEndpointsApiOsmosisGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).osmosisGetAddress(requestParameters.osmosisGetAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiRippleGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public rippleGetAddress(requestParameters: KeepKeyWalletEndpointsApiRippleGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).rippleGetAddress(requestParameters.rippleGetAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeepKeyWalletEndpointsApiThorchainGetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepKeyWalletEndpointsApi
     */
    public thorchainGetAddress(requestParameters: KeepKeyWalletEndpointsApiThorchainGetAddressRequest, options?: AxiosRequestConfig) {
        return KeepKeyWalletEndpointsApiFp(this.configuration).thorchainGetAddress(requestParameters.thorchainGetAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RawKeepKeyDeviceI0EndpointsApi - axios parameter creator
 * @export
 */
export const RawKeepKeyDeviceI0EndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDevice: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchange/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WriteBody} writeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeDevice: async (writeBody: WriteBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'writeBody' is not null or undefined
            assertParamExists('writeDevice', 'writeBody', writeBody)
            const localVarPath = `/exchange/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(writeBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RawKeepKeyDeviceI0EndpointsApi - functional programming interface
 * @export
 */
export const RawKeepKeyDeviceI0EndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RawKeepKeyDeviceI0EndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDevice(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDevice(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WriteBody} writeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeDevice(writeBody: WriteBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WriteDevice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.writeDevice(writeBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RawKeepKeyDeviceI0EndpointsApi - factory interface
 * @export
 */
export const RawKeepKeyDeviceI0EndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RawKeepKeyDeviceI0EndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDevice(options?: any): AxiosPromise<ReadDevice200Response> {
            return localVarFp.readDevice(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WriteBody} writeBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeDevice(writeBody: WriteBody, options?: any): AxiosPromise<WriteDevice200Response> {
            return localVarFp.writeDevice(writeBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for writeDevice operation in RawKeepKeyDeviceI0EndpointsApi.
 * @export
 * @interface RawKeepKeyDeviceI0EndpointsApiWriteDeviceRequest
 */
export interface RawKeepKeyDeviceI0EndpointsApiWriteDeviceRequest {
    /**
     * 
     * @type {WriteBody}
     * @memberof RawKeepKeyDeviceI0EndpointsApiWriteDevice
     */
    readonly writeBody: WriteBody
}

/**
 * RawKeepKeyDeviceI0EndpointsApi - object-oriented interface
 * @export
 * @class RawKeepKeyDeviceI0EndpointsApi
 * @extends {BaseAPI}
 */
export class RawKeepKeyDeviceI0EndpointsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawKeepKeyDeviceI0EndpointsApi
     */
    public readDevice(options?: AxiosRequestConfig) {
        return RawKeepKeyDeviceI0EndpointsApiFp(this.configuration).readDevice(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RawKeepKeyDeviceI0EndpointsApiWriteDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawKeepKeyDeviceI0EndpointsApi
     */
    public writeDevice(requestParameters: RawKeepKeyDeviceI0EndpointsApiWriteDeviceRequest, options?: AxiosRequestConfig) {
        return RawKeepKeyDeviceI0EndpointsApiFp(this.configuration).writeDevice(requestParameters.writeBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecoveryEndpointsApi - axios parameter creator
 * @export
 */
export const RecoveryEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePin: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changePin', 'body', body)
            const localVarPath = `/changePin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecoverDevice} recoverDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recover: async (recoverDevice: RecoverDevice, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recoverDevice' is not null or undefined
            assertParamExists('recover', 'recoverDevice', recoverDevice)
            const localVarPath = `/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoverDevice, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCharacter: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sendCharacter', 'body', body)
            const localVarPath = `/sendCharacter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCharacterDelete: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sendCharacterDelete', 'body', body)
            const localVarPath = `/sendCharacterDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCharacterDone: async (body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sendCharacterDone', 'body', body)
            const localVarPath = `/sendCharacterDone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWord: async (body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sendWord', 'body', body)
            const localVarPath = `/sendWord`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecoveryEndpointsApi - functional programming interface
 * @export
 */
export const RecoveryEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecoveryEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePin(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePin(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecoverDevice} recoverDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recover(recoverDevice: RecoverDevice, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recover(recoverDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCharacter(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCharacter(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCharacterDelete(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCharacterDelete(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCharacterDone(body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCharacterDone(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendWord(body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ETHSignedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendWord(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecoveryEndpointsApi - factory interface
 * @export
 */
export const RecoveryEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecoveryEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePin(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.changePin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecoverDevice} recoverDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recover(recoverDevice: RecoverDevice, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.recover(recoverDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCharacter(body: string, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.sendCharacter(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCharacterDelete(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.sendCharacterDelete(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCharacterDone(body: any, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.sendCharacterDone(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWord(body: string, options?: any): AxiosPromise<ETHSignedTx> {
            return localVarFp.sendWord(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePin operation in RecoveryEndpointsApi.
 * @export
 * @interface RecoveryEndpointsApiChangePinRequest
 */
export interface RecoveryEndpointsApiChangePinRequest {
    /**
     * 
     * @type {any}
     * @memberof RecoveryEndpointsApiChangePin
     */
    readonly body: any
}

/**
 * Request parameters for recover operation in RecoveryEndpointsApi.
 * @export
 * @interface RecoveryEndpointsApiRecoverRequest
 */
export interface RecoveryEndpointsApiRecoverRequest {
    /**
     * 
     * @type {RecoverDevice}
     * @memberof RecoveryEndpointsApiRecover
     */
    readonly recoverDevice: RecoverDevice
}

/**
 * Request parameters for sendCharacter operation in RecoveryEndpointsApi.
 * @export
 * @interface RecoveryEndpointsApiSendCharacterRequest
 */
export interface RecoveryEndpointsApiSendCharacterRequest {
    /**
     * 
     * @type {string}
     * @memberof RecoveryEndpointsApiSendCharacter
     */
    readonly body: string
}

/**
 * Request parameters for sendCharacterDelete operation in RecoveryEndpointsApi.
 * @export
 * @interface RecoveryEndpointsApiSendCharacterDeleteRequest
 */
export interface RecoveryEndpointsApiSendCharacterDeleteRequest {
    /**
     * 
     * @type {any}
     * @memberof RecoveryEndpointsApiSendCharacterDelete
     */
    readonly body: any
}

/**
 * Request parameters for sendCharacterDone operation in RecoveryEndpointsApi.
 * @export
 * @interface RecoveryEndpointsApiSendCharacterDoneRequest
 */
export interface RecoveryEndpointsApiSendCharacterDoneRequest {
    /**
     * 
     * @type {any}
     * @memberof RecoveryEndpointsApiSendCharacterDone
     */
    readonly body: any
}

/**
 * Request parameters for sendWord operation in RecoveryEndpointsApi.
 * @export
 * @interface RecoveryEndpointsApiSendWordRequest
 */
export interface RecoveryEndpointsApiSendWordRequest {
    /**
     * 
     * @type {string}
     * @memberof RecoveryEndpointsApiSendWord
     */
    readonly body: string
}

/**
 * RecoveryEndpointsApi - object-oriented interface
 * @export
 * @class RecoveryEndpointsApi
 * @extends {BaseAPI}
 */
export class RecoveryEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {RecoveryEndpointsApiChangePinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryEndpointsApi
     */
    public changePin(requestParameters: RecoveryEndpointsApiChangePinRequest, options?: AxiosRequestConfig) {
        return RecoveryEndpointsApiFp(this.configuration).changePin(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecoveryEndpointsApiRecoverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryEndpointsApi
     */
    public recover(requestParameters: RecoveryEndpointsApiRecoverRequest, options?: AxiosRequestConfig) {
        return RecoveryEndpointsApiFp(this.configuration).recover(requestParameters.recoverDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecoveryEndpointsApiSendCharacterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryEndpointsApi
     */
    public sendCharacter(requestParameters: RecoveryEndpointsApiSendCharacterRequest, options?: AxiosRequestConfig) {
        return RecoveryEndpointsApiFp(this.configuration).sendCharacter(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecoveryEndpointsApiSendCharacterDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryEndpointsApi
     */
    public sendCharacterDelete(requestParameters: RecoveryEndpointsApiSendCharacterDeleteRequest, options?: AxiosRequestConfig) {
        return RecoveryEndpointsApiFp(this.configuration).sendCharacterDelete(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecoveryEndpointsApiSendCharacterDoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryEndpointsApi
     */
    public sendCharacterDone(requestParameters: RecoveryEndpointsApiSendCharacterDoneRequest, options?: AxiosRequestConfig) {
        return RecoveryEndpointsApiFp(this.configuration).sendCharacterDone(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecoveryEndpointsApiSendWordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryEndpointsApi
     */
    public sendWord(requestParameters: RecoveryEndpointsApiSendWordRequest, options?: AxiosRequestConfig) {
        return RecoveryEndpointsApiFp(this.configuration).sendWord(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}


